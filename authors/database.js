'use strict';

require("@babel/polyfill");
const _ = require('underscore');
const createError = require('http-errors');

const { Database } = require('../configs.js');
const Joi = require('joi');
const pool = Database.pool();
const { addAuthorSQL, 
        getAllAuthorsSQL,
      } = require('./database_queries.js');

/**
 * Entity used to hold author's data and do the validation of that data
 * when handling the database. 
 *
 * This entity has two possible constructor. The first was created to 
 * receive data from database. It receives the author's id and name.
 *
 * The second was created to be used when receiving a author from the client.
 * The unique parameter is author's name.
 */
class Author {
    constructor(id, name) {
        // This is a hard implementation of constructor overloading...
        if (arguments.length === 1) {
            this.id = null;
            this.name = id;
        } else {
            this.id = id;
            this.name = name;
        }
    }

    /**
     * Checks the the Author's fields are valid to be added to the
     * database or not.
     *
     * @returns {ValidationResult}
     */
    validate() {
        const scheme = {
            id: Joi.number().integer().min(1).allow(null).required(),
            name: Joi.string().min(3).max(30).required(),
        };
        return Joi.validate(this, scheme);
    }
}

/** Adds an Author of type {@link Author} to the database with an autogenerated
 * number ID for that.
 *
 * The data is validate before adding to the database.
 *
 * @param {Author} music the music to be added to the database persistently.
 */
const addAuthor = async (author) => {
    // Validate the author
    const { error, validatedUser } = author.validate();
    if (error) return Promise.reject(error);
    
    // Add author in database
    const addAuthorConfig = {
        text: addAuthorSQL,
        values: [author.name],
    };
    await pool.query(addAuthorConfig);
};

const getAllAuthors = async () => {
    const getAllAuthorsConfig = {
        text: getAllAuthorsSQL,
    };

    const result = await pool.query(getAllAuthorsConfig);
    const authors = result.rows.map(result => ({ id: result.id, name: result.name }));
    return authors;
};

const connect = async () => {
    const queries = { addAuthor, getAllAuthors };
    return queries;
};

/**
 * Exports an object that currently can be used to constructs users and establishes
 * a connection with the database.
 * @module DatabaseModule
 * @exports DatabaseModule
 */
module.exports = { 
    Author, 
    connect, 
};
